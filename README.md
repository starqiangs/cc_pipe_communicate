# cc_pipe_communicate
进程通信 - 管道通信(有名、无名)

### backlog 进程通信
顾名思义，进程通信就是进程之间互相发送信息，交换信息；

```
为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以进程之间想要进行信息交换就必须通过内核。
```

一个进程PCB通常分为内核态和用户态，用户态的东西是一个进城独立拥有的，别的进程访问不了；所以要进行交流就需要访问操作系统的内核；


通常进程间的交互主要分为：
- 管道
- 消息队列
- 共享内存
- 信号量
- 套接字socket

本篇主要实现以管道方法为通信方式的进程间的交互；


### 管道定义
就是在内核创建了一个管道用于进程间的信息交流，但需要注意的是：
`commmand | command` -> `ls | grep 'main`
就是将第一个命令的输出交给第二个命令。｜则就是管道、可以看出来管道只能将信息单向传输，就是`半双工通信`；

```
注意：通过管道符 | 创建的管道是匿名管道，用完了就会被自动销毁。并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用，。也就是说，匿名管道只能用于父子进程之间的通信
```

要想实现双向沟通，则需要实现两个管道；

### 无名管道（管道用完就销毁，只适用于具有血缘关系的进程）
一般创建使用的是int pipe(int fd[2]);

f[0]表示管道的获取，读取/f[1]表示管道信息的写入；

无名管道的作用就好比创建了一个文件，写入这个文件中，又从这个文件中拿出来；因为是半双工的，所以是进程安全的

### 有名管道（无名管道的优化、因为无名，所以只能通过父子进程通信，为了克服，出现了有名）
```
mkfifo ${管道name}
eg： mkfifo my_pipe
```
创建好管道后，就可以通过open函数打开文件操作去读区，去写，
当写完之后，就会陷入堵塞状态，因为管道的内容没被读取，
当管道的内容被读取后，就会释放，其中一个客户端一个服务端，两个进程；